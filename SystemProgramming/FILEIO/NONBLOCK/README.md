# 阻塞（Block)：
 当进程调用一个阻塞的系统函数时，该进程被置于睡眠（Sleep)状态，这时内核调度其它进程运行，直到该进程等待的时间发生了，（比如网络接受到了数据包，或者调用sleep指定的睡眠时间到了）它才有可能继续运行。
与睡眠状态相对的是**运行状态**， 在Linux内核中，处于运行状态的进程分为两种情况：
    - (+*) 正在被调度执行：CPU处于该进程的上下文环境中，程序计数器(eip)里保存着该进程的指令地址，正在执行该进程的指令，正在读写该进程的地址空间。
    - (+*) 就绪状态： 该进程不需要等待什么时间发生，随时都可以执行，但CPU暂时在实行另一个进程，所以该进程在一个就绪队列中等待被内核调度。

如果在open一个设备时指定了O_NONBLOCK标志，read/write就不会阻塞。以read为例，如果设备暂时没有数据可读就返回-1，同时置errno为EWOULDBLOCK（或者EAGAIN，这两个宏定义的值相同)，表示本来应该阻塞在这里(would block，虚拟语气），事实上并没有阻塞而是直接返回错误,调用者应该试着再读一次(again)。这种行为方式称为轮询(Poll)，调用者只是查询一下，而不是阻塞在这里死等，这样可以同时监视多个设备:
``` c
    while(1) {
        非阻塞read(设备1)；
        if（设备1有数据到达）
            处理数据;
        非阻塞read（设备2）
        if(设备2有数据到达)
            处理数据;
        ...
        sleep(n);
    }

```

ls -l /dev/tty 终端下的文件(标准输入,标准输出, 标准错误(error))
